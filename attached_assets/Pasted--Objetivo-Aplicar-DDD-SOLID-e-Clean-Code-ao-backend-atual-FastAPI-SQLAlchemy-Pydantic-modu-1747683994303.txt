ğŸ¯ Objetivo
Aplicar DDD, SOLID e Clean Code ao backend atual (FastAPI + SQLAlchemy + Pydantic), modularizando o sistema, reduzindo acoplamentos e separando corretamente responsabilidades.

ğŸ§± Fase 1 â€” CriaÃ§Ã£o da Base DDD
ğŸ“‚ Nova Estrutura de Pastas (padrÃ£o DDD)
bash
Copiar
Editar
/app
  â”œâ”€â”€ domain/                # Entidades puras (sem ORM)
  â”‚   â””â”€â”€ patient/
  â”‚       â”œâ”€â”€ entities.py    # PatientEntity (sem heranÃ§a SQLAlchemy)
  â”‚       â””â”€â”€ value_objects.py
  â”œâ”€â”€ infrastructure/        # ORM, banco, adapters
  â”‚   â””â”€â”€ repositories/
  â”‚       â””â”€â”€ patient_sqlalchemy.py
  â”œâ”€â”€ application/           # Use cases + interfaces
  â”‚   â””â”€â”€ use_cases/
  â”‚       â””â”€â”€ create_patient.py
  â”œâ”€â”€ interfaces/            # FastAPI routers/controllers
  â”‚   â””â”€â”€ api/
  â””â”€â”€ core/                  # Base classes, erros, utils
ğŸ“Œ Tarefas da Fase 1
Etapa	Tarefa	DescriÃ§Ã£o
1.1	Criar PatientEntity	Entidade de domÃ­nio pura (sem Base) com mÃ©todos como update_contact_info()
1.2	Criar repositÃ³rio abstrato PatientRepository	Interface que define create, get_by_id, etc.
1.3	Implementar PatientSQLAlchemyRepository	ImplementaÃ§Ã£o concreta da interface com SQLAlchemy
1.4	Criar caso de uso CreatePatientUseCase	Classe que executa a lÃ³gica de criaÃ§Ã£o com injeÃ§Ã£o do repositÃ³rio
1.5	Refatorar router para usar o caso de uso	create_patient do FastAPI chamarÃ¡ CreatePatientUseCase.handle()

ğŸ§± Fase 2 â€” InversÃ£o de DependÃªncia (DIP)
Etapa	Tarefa	DescriÃ§Ã£o
2.1	Criar interfaces de todos os repositÃ³rios	Comece por PatientRepository, UserRepository, etc.
2.2	Refatorar serviÃ§os para depender da interface	PatientService nÃ£o deve usar diretamente SQLAlchemy
2.3	Usar Depends() com implementaÃ§Ã£o injetada	Ex: get_patient_repo() retorna a implementaÃ§Ã£o concreta

ğŸ§± Fase 3 â€” Entidades Ricas (Comportamento no DomÃ­nio)
Etapa	Tarefa	DescriÃ§Ã£o
3.1	Mover validaÃ§Ãµes para dentro da entidade	Ex: validar CPF dentro de PatientEntity.__init__()
3.2	Criar mÃ©todos de negÃ³cio	Ex: deactivate(), update_address(), change_status()
3.3	Evitar lÃ³gica no serviÃ§o que pertence Ã  entidade	Deixe os use cases mais limpos

ğŸ§± Fase 4 â€” Camada de AplicaÃ§Ã£o e Casos de Uso
Etapa	Tarefa	DescriÃ§Ã£o
4.1	Criar um caso de uso por operaÃ§Ã£o importante	Ex: CreatePatient, UpdatePatient, DeletePatient
4.2	Casos de uso devem orquestrar: entidades + repositÃ³rios	
4.3	Services devem virar orquestradores ou ser extintos	

ğŸ§± Fase 5 â€” Clean Code e ReutilizaÃ§Ã£o
Etapa	Tarefa	DescriÃ§Ã£o
5.1	Criar PermissionChecker centralizado	Evitar duplicaÃ§Ã£o de checagem de permissÃµes
5.2	Criar ErrorFactory ou ExceptionUtils	Mensagens de erro padronizadas
5.3	Garantir nomes claros, funÃ§Ãµes pequenas e poucos efeitos colaterais	

âœ… Resultado Esperado
Cada camada com responsabilidade Ãºnica (SRP)

Casos de uso isolados para regras de negÃ³cio (DDD)

Baixo acoplamento e alta testabilidade (DIP, ISP)

CÃ³digo limpo, autoexplicativo e expansÃ­vel (Clean Code)

ğŸ“Œ Extras (opcional, mas recomendado)
âœ… Cobertura de testes por camada (testar UseCases e Repositories separadamente)

âœ… IntroduÃ§Ã£o de Value Objects (ex: CPF, Telefone, EndereÃ§o)

âœ… Suporte a mÃºltiplos bancos (ex: SQLite para testes, PostgreSQL na produÃ§Ã£o)

