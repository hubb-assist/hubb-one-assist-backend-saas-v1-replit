Representam funcionalidades do sistema (ex: HOF, Vision, Talk, RH, IA)


Cada m√≥dulo pode ser ativado ou n√£o conforme o plano


‚úÖ Aplica√ß√£o dos Princ√≠pios SOLID no Projeto hubb-one-assist-v1-backend-replit
1. S ‚Äî Single Responsibility Principle (Princ√≠pio da Responsabilidade √önica)
"Cada m√≥dulo ou classe deve ter uma √∫nica responsabilidade, e essa responsabilidade deve estar completamente encapsulada."
Aplica√ß√£o no projeto:
Cada camada tem responsabilidade clara:


app/api/: somente define rotas e recebe requisi√ß√µes.


app/services/: concentra as regras de neg√≥cio (casos de uso).


app/db/models/: define a estrutura do banco.


app/schemas/: define as valida√ß√µes de entrada e sa√≠da.


app/core/: configura√ß√µes gerais, autentica√ß√£o, seguran√ßa.


Nenhum m√≥dulo deve misturar responsabilidades de dom√≠nio com l√≥gica de requisi√ß√£o, nem l√≥gica de banco com valida√ß√µes.



2. O ‚Äî Open/Closed Principle (Aberto para Extens√£o, Fechado para Modifica√ß√£o)
"Entidades devem estar abertas para extens√£o, mas fechadas para modifica√ß√£o."
Aplica√ß√£o no projeto:
O backend ser√° modular: novos m√≥dulos (como financeiro, agenda, custos) podem ser adicionados sem alterar os existentes, apenas integrando novos arquivos no padr√£o j√° definido.


Utiliza√ß√£o de interfaces e servi√ßos desacoplados: por exemplo, um servi√ßo de envio de e-mail pode ser substitu√≠do por outro sem alterar as chamadas do c√≥digo que o consome.



3. L ‚Äî Liskov Substitution Principle (Princ√≠pio da Substitui√ß√£o de Liskov)
"Objetos devem poder ser substitu√≠dos por inst√¢ncias de suas subclasses sem afetar o funcionamento do sistema."
Aplica√ß√£o no projeto:
Servi√ßos e controladores usar√£o tipagem expl√≠cita e Pydantic com heran√ßa segura, permitindo que UserBase, UserCreate, UserUpdate compartilhem atributos, mas sejam usados conforme o contexto, sem quebrar valida√ß√µes.


Em testes, ser√° poss√≠vel substituir classes de servi√ßos reais por mocks, sem comprometer o comportamento da aplica√ß√£o.



4. I ‚Äî Interface Segregation Principle (Princ√≠pio da Segrega√ß√£o de Interface)
"Muitos contratos espec√≠ficos s√£o melhores do que um contrato √∫nico e geral."
Aplica√ß√£o no projeto:
Os endpoints e servi√ßos seguir√£o contratos pequenos e separados:


Em vez de um controller gigantesco, haver√° divis√£o clara de rotas por dom√≠nio (auth_routes.py, user_routes.py, etc.).


Servi√ßos tamb√©m seguem esse padr√£o: AuthService, UserService, PlanoService, etc.



5. D ‚Äî Dependency Inversion Principle (Princ√≠pio da Invers√£o de Depend√™ncia)
"M√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel, ambos devem depender de abstra√ß√µes."
Aplica√ß√£o no projeto:
Utiliza√ß√£o de inje√ß√£o de depend√™ncia do FastAPI para entregar servi√ßos (Depends(AuthService)).


Servi√ßos de reposit√≥rio e l√≥gica de neg√≥cio ser√£o injetados, nunca instanciados diretamente.


Isso permite trocar implementa√ß√µes facilmente (ex: trocar o servi√ßo de envio de notifica√ß√£o por outro, apenas mudando a depend√™ncia).



‚ú≥Ô∏è Resultado esperado:
Seguindo esses princ√≠pios, o backend do HUBB Assist ser√°:
Robusto


Test√°vel


Modular


F√°cil de manter e expandir


Pronto para escalar com seguran√ßa


A seguir est√° uma explica√ß√£o clara, pr√°tica e totalmente contextualizada de como o DDD (Domain-Driven Design) ser√° aplicado no backend do projeto hubb-one-assist-v1-backend-replit:

‚úÖ Aplica√ß√£o de DDD ‚Äî Domain-Driven Design no Backend do HUBB Assist
Objetivo do DDD:
 Manter a complexidade do sistema sob controle ao modelar o c√≥digo diretamente com base na l√≥gica de neg√≥cio real, separando as responsabilidades t√©cnicas da regra de neg√≥cio central.

üß± Camadas do Projeto com DDD
1. Camada de Dom√≠nio (app/services/ e app/schemas/)
Representa a l√≥gica de neg√≥cio do HUBB Assist: cadastro de assinantes, planos, usu√°rios, permiss√µes, etc.


Cada servi√ßo de dom√≠nio encapsula um "caso de uso", por exemplo:


CreateAssinanteService


ChangeUserPasswordService


CalculatePlanCostService


Essa camada n√£o depende de FastAPI, banco ou rotas.


2. Camada de Aplica√ß√£o (app/api/)
Respons√°vel por expor a aplica√ß√£o ao mundo exterior (HTTP).


Define as rotas (@router.get, @router.post) e orquestra chamadas aos servi√ßos de dom√≠nio.


Essa camada n√£o implementa regra de neg√≥cio, apenas chama os casos de uso da camada de dom√≠nio e responde com JSONResponse.


3. Camada de Infraestrutura (app/db/ e app/core/)
Cont√©m os detalhes t√©cnicos: acesso ao banco (SQLAlchemy), migra√ß√µes (Alembic), autentica√ß√£o, middlewares, configura√ß√µes de ambiente.


Tamb√©m pode conter servi√ßos de integra√ß√£o externa, como: envio de e-mail, storage, webhooks, etc.


Essas implementa√ß√µes s√£o injetadas como depend√™ncias nos servi√ßos de dom√≠nio, nunca chamadas diretamente da camada de aplica√ß√£o.



üì¶ Organiza√ß√£o Modular por Dom√≠nio
O c√≥digo ser√° dividido por m√≥dulos de neg√≥cio, com subpastas contendo os arquivos de cada camada:
css
CopiarEditar
app/
‚îú‚îÄ‚îÄ domains/
‚îÇ   ‚îú‚îÄ‚îÄ assinantes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repository.py
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îú‚îÄ‚îÄ usuarios/
‚îÇ   ‚îî‚îÄ‚îÄ planos/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ routes_assinantes.py
‚îÇ   ‚îú‚îÄ‚îÄ routes_auth.py
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ core/
‚îú‚îÄ‚îÄ db/
‚îú‚îÄ‚îÄ main.py


üí° Exemplo real no projeto HUBB Assist:
A cria√ß√£o de um novo assinante:


routes_assinantes.py ‚Üí recebe os dados e chama:


CriarAssinanteService.handle() ‚Üí executa as regras, valida√ß√µes e chama:


AssinanteRepository.create() ‚Üí persiste no banco via SQLAlchemy.


A rota n√£o conhece os detalhes do banco, nem o banco conhece a regra de neg√≥cio.

üìå Benef√≠cios esperados com DDD:
Clareza sobre as regras de neg√≥cio


Isolamento de complexidade t√©cnica


Facilidade de testes unit√°rios


Escalabilidade horizontal da aplica√ß√£o


Flexibilidade para troca de tecnologias (ex: outro banco ou API externa)


‚úÖ Aplica√ß√£o de Clean Code no Backend do HUBB Assist
Objetivo do Clean Code:
 Escrever c√≥digo leg√≠vel, simples, sem duplica√ß√£o e f√°cil de entender, mesmo por outros desenvolvedores que n√£o participaram da implementa√ß√£o original. C√≥digo limpo n√£o apenas funciona ‚Äî ele comunica.

üßº Pr√°ticas de Clean Code no projeto
1. Nomea√ß√£o clara e sem ambiguidade
Fun√ß√µes, vari√°veis, rotas e arquivos ter√£o nomes descritivos com inten√ß√£o expl√≠cita.


Ruim: def proc(data):


Bom: def create_assinante(assinante_data: AssinanteCreateSchema):


Pastas organizadas por contexto, n√£o por tipo gen√©rico (ex: usuarios/service.py ao inv√©s de services/users.py).


2. Fun√ß√µes pequenas com responsabilidade √∫nica
Nenhuma fun√ß√£o deve fazer mais de uma coisa.


Regras complexas ser√£o quebradas em pequenos m√©todos reutiliz√°veis dentro do service.


3. Sem c√≥digo duplicado
Qualquer l√≥gica repetida ser√° extra√≠da para:


utils/


core/validators.py


ou fun√ß√µes reutiliz√°veis nos pr√≥prios servi√ßos.


4. Tratamento expl√≠cito de erros
Toda exce√ß√£o ser√° tratada com mensagens claras, usando o sistema de HTTPException e handlers globais.


Logs ser√£o estruturados com contexto: quem, onde e por qu√™ algo falhou.


5. Separa√ß√£o entre l√≥gica e efeitos colaterais
Nenhum c√≥digo de banco, envio de email ou integra√ß√£o externa dentro dos services diretamente.


Toda intera√ß√£o com o mundo externo ser√° mediada por repositories ou adapters.


6. Arquivos curtos e objetivos
Cada arquivo ter√° um foco. Exemplo:


auth_service.py trata apenas de login e tokens.


user_service.py trata cria√ß√£o, edi√ß√£o e dele√ß√£o de usu√°rios.


Quando um arquivo crescer demais, ele ser√° dividido em m√∫ltiplos por fun√ß√£o ou contexto.



‚ú≥Ô∏è Conven√ß√µes e boas pr√°ticas adotadas
PEP8: Estilo Python padronizado.


Tipagem est√°tica com mypy e pyright para valida√ß√£o de tipos.


Black e isort: formata√ß√£o e ordena√ß√£o autom√°tica dos arquivos.


Coment√°rios e docstrings ser√£o usados apenas quando o nome da fun√ß√£o n√£o for autoexplicativo.



‚úÖ Resultado esperado
Com Clean Code aplicado junto a SOLID e DDD:
O backend ser√° autoexplicativo, test√°vel e sustent√°vel.


Novos desenvolvedores entender√£o o projeto rapidamente.


Bugs ser√£o minimizados e mudan√ßas se tornar√£o seguras e previs√≠veis.
